## 1.2.1 算法的定义

### 算法(Algorithm)

- 一个有限指令集
- 接受一些输入（有时也无需输入）
- 产生输出
- 在有限步骤后终止
- 每条指令必须：
	- 有充分明确的目标，不可以有歧义
	- 计算机能处理的范围之内
	- 描述应不依赖于任何一种计算机语言以及具体的实现手段
例如：选择排序的伪码描述
```c
void SelectionSort ( int List[], int N ) { 
/* 将N个整数List[0]...List[N-1]进行非递减排序 */ 

	for ( i = 0; i < N; i ++ ) { 
	
	MinPosition = ScanForMin( List, i, N–1 ); 
	/* 从List[i]到List[N–1]中找最小元，并将其位置赋给MinPosition */
	Swap( List[i], List[MinPosition] ); 
	/* 将未排序部分的最小元换到有序部分的最后位置 */ 
	} 
}
```

- 抽象：
	- `List` 到底是数组还是链表（虽然看上去很像数组）？
	- `Swap` 用函数还是用宏去实现？

## 1.2.2 什么是好的算法

通常有两个指标：

### 空间复杂度$S(n)$

根据算法写成的程序在执行时**占用存储单元的长度**。这个长度往往与输入数据的 规模有关。空间复杂度过高的算法可能导致使用的 内存超限，造成程序非正常中断。

如：
```c
void PrintN ( int N ) { 
	if ( N ){ 
		PrintN( N – 1 ); 
		printf(“%d\n”, N ); 
	} 
	return; 
}
```
此时空间的利用与N的大小呈正相关： $S(N) = C·N$

### 时间复杂度$T(n)$

根据算法写成的程序在执行时**耗费时间的长度**。这个长度往往也与输入数据的规 模有关。时间复杂度过高的低效算法可能导致我们 在有生之年都等不到运行结果。

如：多项式
```c
double f( int n, double a[], double x ) { 
	int i; double p = a[0]; 

	for ( i=1; i<=n; i++ ) 
		p += (a[i] * pow(x, i)); 
	
	return p; 
}
```
- (1+2+……+n) =(n2+n)/2次乘法
- $T(n) = C_1n^2+C_2n$

```c
double f( int n, double a[], double x ) { 
	int i; double p = a[n]; 
	for ( i=n; i>0; i-- ) 
		p = a[i-1] + x*p; 
	return p; 
}
```
- n次乘法
- $T(n) = C · n$

### 总结

在分析一般算法的效率时，我们经常关注下面两种复杂度
- 最坏情况复杂度 $T_{worst}( n )$ (一般更关注)
- 平均复杂度 $T_{avg}( n )$
$$T_{avg}( n ) \le T_{worst}( n )$$

## 1.2.3 算法的渐近度表示

> [!FAQ] 随着要处理的数据规模增大，复杂度增长的性质会怎么样

- $T( n ) = O(f( n ))$ 表示存在常数$C > 0$, $n_0>0$ 使得当 $n \ge n_0$ 时有 $T( n ) \le C·f( n )$ (一般为最小上界)
- $T( n ) = \Omega (g ( n ))$ 表示存在常数$C > 0$, $n_0>0$ 使得当 $n \ge n_0$ 时有 $T( n) \ge C·g ( n )$ (一般为最大下界)
- $T( n) = \Theta ( h ( n ))$ 表示同时有 $T( n ) = O( h ( n ))$ 和 $T( n) = \Omega ( h ( n ))$
