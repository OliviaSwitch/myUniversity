## 1.2.1 算法的定义

### 算法(Algorithm)

- 一个有限指令集
- 接受一些输入（有时也无需输入）
- 产生输出
- 在有限步骤后终止
- 每条指令必须：
	- 有充分明确的目标，不可以有歧义
	- 计算机能处理的范围之内
	- 描述应不依赖于任何一种计算机语言以及具体的实现手段
例如：选择排序的伪码描述
```c
void SelectionSort ( int List[], int N ) { 
/* 将N个整数List[0]...List[N-1]进行非递减排序 */ 

	for ( i = 0; i < N; i ++ ) { 
	
	MinPosition = ScanForMin( List, i, N–1 ); 
	/* 从List[i]到List[N–1]中找最小元，并将其位置赋给MinPosition */
	Swap( List[i], List[MinPosition] ); 
	/* 将未排序部分的最小元换到有序部分的最后位置 */ 
	} 
}
```

- 抽象：
	- `List` 到底是数组还是链表（虽然看上去很像数组）？
	- `Swap` 用函数还是用宏去实现？

## 1.2.2 什么是好的算法

通常有两个指标：

### 空间复杂度`S(n)`

根据算法写成的程序在执行时**占用存储单元的长度**。这个长度往往与输入数据的 规模有关。空间复杂度过高的算法可能导致使用的 内存超限，造成程序非正常中断。

如：
```c
void PrintN ( int N ) { 
	if ( N ){ 
		PrintN( N – 1 ); 
		printf(“%d\n”, N ); 
	} 
	return; 
}
```
此时空间的利用与N的大小呈正相关： `S(N) = C·N`

### 时间复杂度`T(n)`

根据算法写成的程序在执行时**耗费时间的长度**。这个长度往往也与输入数据的规 模有关。时间复杂度过高的低效算法可能导致我们 在有生之年都等不到运行结果。

如：多项式
```c
double f( int n, double a[], double x ) { 
	int i; double p = a[0]; 

	for ( i=1; i<=n; i++ ) 
		p += (a[i] * pow(x, i)); 
	
	return p; 
}
```


```c
double f( int n, double a[], double x ) { 
	int i; double p = a[n]; 
	for ( i=n; i>0; i-- ) 
		p = a[i-1] + x*p; 
	return p; 
}
```

## 1.2.3 算法的渐近度表示
