## 1.2.1 算法的定义

### 算法(Algorithm)

- 一个有限指令集
- 接受一些输入（有时也无需输入）
- 产生输出
- 在有限步骤后终止
- 每条指令必须：
	- 有充分明确的目标，不可以有歧义
	- 计算机能处理的范围之内
	- 描述应不依赖于任何一种计算机语言以及具体的实现手段
例如：选择排序的伪码描述
```c
void SelectionSort ( int List[], int N ) { 
/* 将N个整数List[0]...List[N-1]进行非递减排序 */ 

	for ( i = 0; i < N; i ++ ) { 
	
	MinPosition = ScanForMin( List, i, N–1 ); 
	/* 从List[i]到List[N–1]中找最小元，并将其位置赋给MinPosition */
	Swap( List[i], List[MinPosition] ); 
	/* 将未排序部分的最小元换到有序部分的最后位置 */ 
	} 
}
```

- 抽象：
	- `List` 到底是数组还是链表（虽然看上去很像数组）？
	- `Swap` 用函数还是用宏去实现？

## 1.2.2 什么是好的算法

通常有两个指标：

### 空间复杂度$S(n)$

根据算法写成的程序在执行时**占用存储单元的长度**。这个长度往往与输入数据的 规模有关。空间复杂度过高的算法可能导致使用的 内存超限，造成程序非正常中断。

如：
```c
void PrintN ( int N ) { 
	if ( N ){ 
		PrintN( N – 1 ); 
		printf(“%d\n”, N ); 
	} 
	return; 
}
```
此时空间的利用与N的大小呈正相关： $S(N) = C·N$

### 时间复杂度$T(n)$

根据算法写成的程序在执行时**耗费时间的长度**。这个长度往往也与输入数据的规 模有关。时间复杂度过高的低效算法可能导致我们 在有生之年都等不到运行结果。

如：多项式
```c
double f( int n, double a[], double x ) { 
	int i; double p = a[0]; 

	for ( i=1; i<=n; i++ ) 
		p += (a[i] * pow(x, i)); 
	
	return p; 
}
```
- (1+2+……+n) =(n2+n)/2次乘法
- $T(n) = C_1n^2+C_2n$

```c
double f( int n, double a[], double x ) { 
	int i; double p = a[n]; 
	for ( i=n; i>0; i-- ) 
		p = a[i-1] + x*p; 
	return p; 
}
```
- n次乘法
- $T(n) = C · n$

### 总结

在分析一般算法的效率时，我们经常关注下面两种复杂度
- 最坏情况复杂度 $T_{worst}( n )$ (一般更关注)
- 平均复杂度 $T_{avg}( n )$
$$T_{avg}( n ) \le T_{worst}( n )$$

## 1.2.3 算法的渐近度表示

> [!FAQ] 随着要处理的数据规模增大，复杂度增长的性质会怎么样

- $T( n ) = O(f( n ))$ 表示存在常数$C > 0$, $n_0>0$ 使得当 $n \ge n_0$ 时有 $T( n ) \le C·f( n )$ (一般为最小上界)
- $T( n ) = \Omega (g ( n ))$ 表示存在常数$C > 0$, $n_0>0$ 使得当 $n \ge n_0$ 时有 $T( n) \ge C·g ( n )$ (一般为最大下界)
- $T( n) = \Theta ( h ( n ))$ 表示同时有 $T( n ) = O( h ( n ))$ 和 $T( n) = \Omega ( h ( n ))$

### 输入规模 $n$

| 时间复杂度   | 符号表示                | n=1 | n=2 | n=4 | n=8   | n=16          | n=32                  | 常见算法示例                                                                  |
| ------------ | ----------------------- | --- | --- | --- | ----- | ------------- | --------------------- | ----------------------------------------------------------------------------- |
| 常数级别     | $O(1)$                  | 1   | 1   | 1   | 1     | 1             | 1                     | 数组访问、加减乘除等基本操作                                                  |
| 对数级别     | $O(\log n)$             | 0   | 1   | 2   | 3     | 4             | 5                     | 二分查找、平衡二叉树的查询                                                    |
| 线性级别     | $O(n)$                  | 1   | 2   | 4   | 8     | 16            | 32                    | 数组遍历、线性查找                                                            |
| 线性对数级别 | $O(n\log n)$            | 0   | 2   | 8   | 24    | 64            | 160                   | 归并排序、快速排序                                                            |
| 平方级别     | $O(n^2)$                | 1   | 4   | 16  | 64    | 256           | 1024                  | 选择排序、插入排序                                                            |
| 立方级别     | $O(n^3)$                | 1   | 8   | 64  | 512   | 4096          | 32768                 | 矩阵乘法                                                                      |
| 指数级别     | $O(2^n)$ 或 $O(3^n)$ 等 | 2   | 4   | 16  | 256   | 65536         | 4294967296            | 旅行商问题                                                                    |
| 乘阶级别     | $n!$                    | 1   | 2   | 24  | 40326 | 2092278988000 | $26313\times 10_{33}$ | 旅行商问题和分配问题 |

> [!attention] 尽量不要使用后两种

### 复杂度分析小窍门

- 若两段算法分别有复杂度$T_1(n)=O(f_1(n))$和$T_2(n)=O(f_2(n))$则
    - $T_1(n)+T_2(n)=max(O(f_1),O(f_2(n)))$ 
    - $T_1(n)\times T_2(n)=O(f_1(n)\times T_2(n))$
- 若$T(n)$是关于$n$的$k$阶多项式，则$T(n)=\Theta (n^k)$
- 一个**for**循环的时间复杂度等于循环次数乘以循环体代码的复杂度
- **if-else**结构的复杂度取决于**if**的条件判断复杂度和两个分枝部分的复杂度，总复杂度取三者中最大