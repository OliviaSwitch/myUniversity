# 继承与多态

## 继承

> 面向对象程序设计语言有三大特性：封装、继承和多态性。继承是面向对象语言的重要特征之一。
>
> 基于已有的设计创造新的设计，就是面向对象程序设计中的继承。在继承中，新的类不是凭空产生的，而是基于一个已经存在的类而定义出来的。通过继承，新的类自动获得了基础类中所有的成员，包括成员变量和方法，包括各种访问属性的成员，无论是public还是private。
>
> 显然，通过继承来定义新的类，远比从头开始写一个新的类要简单快捷和方便。继承是支持代码重用的重要手段之一。

### 媒体资料库的设计

- CD
    - title
    - artist
    - Ntrackers
    - playing time
    - got it
    - comment

```java
//Database.java
import java.util.ArrayList;

public class Database {
	private ArrayList<CD> listCD = new ArrayList<CD>();
	
	public void add(CD cd) {
		listCD.add(cd);
	}
	public void list() {
		for(CD cd:listCD) {
			cd.print();
		}
	}
	
	public static void main(String[] args) {
		Database db = new Database();
		db.add(new CD("abc", "abc", 4, 60, "..."));
		db.add(new CD("abc", "abc", 4, 60, "..."));
		db.list();

	}
}
```

```java
//CD.java
public class CD {
	private String title;
	private String artist;
	private int numofTracks;
	private int playingTime;
	private boolean gotIt=false;
	private String comment;

	public CD(String title, String artist, int numofTracks, int playingTime, String comment) {
//		super();
		this.title = title;
		this.artist = artist;
		this.numofTracks = numofTracks;
		this.playingTime = playingTime;
		this.comment = comment;
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

	public void print() {
		System.out.println(title+":"+artist);
	}
}
```

> 如果多加一个类的话，会产生许多重复的代码。

### 继承

> 不如做一个公共的东西，database只需管理一类即可。
>
> 我们把用来做基础派生其它类的那个类叫做父类、超类或者基类，而派生出来的新类叫做子类。Java用关键字extends表示这种继承/派生关系：
>
> ```java
> class ThisClass extends SuperClass { 
>     //…
> }
> ```
>
> 继承表达了一种is-a关系，就是说，子类的对象可以被看作是父类的对象。Java的继承只允许单继承，即一个类只能有一个父类。

## 子类与父类

> 子类从父类那里得到了所有的东西，所有的父类的成员，包括变量和方法，都成为了子类的成员，**除了构造方法**。构造方法是父类所独有的，因为它们的名字就是类的名字，所以父类的构造方法在子类中不存在。除此之外，子类继承得到了父类所有的成员。
>
> 但是得到不等于可以随便使用。每个成员有不同的访问属性，子类继承得到了父类所有的成员，但是不同的访问属性使得子类在使用这些成员时有所不同：有些父类的成员直接成为子类的对外的界面，有些则被深深地隐藏起来，即使子类自己也不能直接访问。
>
> | **父类成员访问属性** | **在父类中的含义**                 | **在子类中的含义**                                           |
> | -------------------- | ---------------------------------- | ------------------------------------------------------------ |
> | public               | 对所有人开放                       | 对所有人开放                                                 |
> | protected            | 只有包内其它类、自己和子类可以访问 | 只有包内其它类、自己和子类可以访问                           |
> | 缺省                 | 只有包内其它类可以访问             | 如果子类与父类在同一个包内：只有包内其它类可以访问否则：相当于private，不能访问 |
> | private              | 只有自己可以访问                   | 不能访问                                                     |
>
> 我们不可以在子类中重新定义继承得到的成员的访问属性。如果我们试图重新定义一个在父类中已经存在的成员变量，那么我们是在定义一个与父类的成员变量完全无关的变量，在子类中我们可以访问这个定义在子类中的变量，在父类的方法中访问父类的那个。尽管它们同名但是互不影响。
>
> 在构造一个子类的对象时，父类的构造方法也是会被调用的，而且父类的构造方法在子类的构造方法之前被调用。在程序运行过程中，子类对象的一部分空间存放的是父类对象。因为子类从父类得到继承，在子类对象初始化过程中可能会使用到父类的成员。所以父类的空间正是要先被初始化的，然后子类的空间才得到初始化。在这个过程中，如果父类的构造方法需要参数，如何**传递参数**就很重要了。

### 传递参数

`super()`: 可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。调用父类中的某一个构造函数

## 多态变量和向上造型

> 类定义了类型,类可以有子类,所以由那些类定义的类型可以有子类型。
>
> 子类型类似于类的层次,类型也构成了类型层次。子类所定义的类型是其超类的类型的子类型。
>
> 当把一个对象赋值给一个变量时,对象的类型必须与变量的类型相匹配,如:
>
> ```java
> Car myCar = new Car(); 
> ```
>
> 是一个有效的赋值,因为Car类型的对象被赋值给声明为保存Car类型对象的变量。但是由于引入 了继承,这里的类型规则就得叙述得更完整些:
>
> ​    **一个变量可以保存其所声明的类型或该类型的任何子类型。**
>
> Java中保存对象类型的变量是多态变量。“多态”这个术语(字面意思是许多形态)是指一个变量可以保存不同类型(即其声明的类型或任何子类型)的对象。

### 多态变量

- Java 的对象变量是多态的，它们能保存不止一种类型的对象
- 它们可以保存的是声明类型的对象，或声明类型的子类的对象
- 当把字类的对象赋给父类的变量时，就发生了**向上造型**

#### 子类和类型

- 类定义类型
- 子类定义子类型
- 子类的对象可以被当作父类的对象来使用
    - 赋值给父类的变量
    - 传递给需要父类对象的函数
    -  放进存放父类对象的容器里

### 向上造型

- 子类的对象可以赋值给父类的变量

    - Java 中没有对象对对象的赋值
    - 向上造型是默认的，不需要运算符
    - 向上造型总是安全的

- 父类的对象不能赋值给子类变量

    ```java
    Vechicle v;
    Car c;
    v = c;//yes 此为向上造型
    c = v;//no 编译错误！
    ```

- 可以用**造型(Cast)**：
    `c = (Car) v;`

    只有当 v 这个变量实际管理的是 Car 才行

    - 对象本身没有改变，所以不是类型转换
    - 检查转化是否合理：`ClassCastException`

## 多态

> 如果子类的方法覆盖了父类的方法，也就是说父类的那个方法在子类有了新的版本或者新的实现。覆盖的新版本具有与老版本相同的方法签名：相同的方法名称和参数表。因此，对于外界来说，子类并没有增加新的方法，仍然是在父类中定义过的那个方法。不同的是，这是一个新版本，所以通过子类的对象调用这个方法，执行的是子类自己的方法。
>
> 当调用一个方法时，究竟应该调用哪个方法，这件事情叫做绑定。绑定表明了调用一个方法的时候，我们使用的是哪个方法。绑定有两种：一种是早绑定，又称静态绑定，这种绑定在编译的时候就确定了；另一种是晚绑定，即动态绑定。动态绑定在运行的时候根据变量当时实际所指的对象的类型动态决定调用的方法。Java 默认使用动态绑定。
>
> 多态体现为**父类引用变量可以指向子类对象**。同一个接口，使用不同的实例而执行不同操作。

### 函数调用的绑定

通过对象变量来调用函数时，调用哪个函数这件事叫绑定

- 静态绑定：根据变量的声明类型决定
- 动态绑定：根据变量的动态类型决定

在成员函数中调用其他成员函数也是通过 this 这个对象变量来调用的

### 覆盖 override

- 子类和父类中名称和参数表完全相同的函数构成覆盖关系
- 通过父类调用存在覆盖关系的函数时，会调用函数当时所属类的函数

## 类型系统

### Object 类

Java 是单根结构，所有的类都是继承 Object 类的。

#### Object 类的函数

- `toString()`
- `equals()`

